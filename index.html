<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Robotics</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Robotics</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#d-geometry">2D Geometry</a><ul>
<li><a href="#d-geometry-refresher">2D Geometry Refresher</a></li>
<li><a href="#position-and-pose-in-2d">Position and pose in 2D</a></li>
<li><a href="#relative-positions-in-2d">Relative positions in 2D</a></li>
<li><a href="#relative-pose-in-2d">Relative pose in 2D</a></li>
<li><a href="#describing-rotation-in-2d">Describing rotation in 2D</a></li>
<li><a href="#describing-rotation-and-translation-in-2d">Describing rotation and translation in 2D</a></li>
</ul></li>
<li><a href="#d-geometry-1">3D Geometry</a><ul>
<li><a href="#relative-pose-in-3d">Relative pose in 3D</a></li>
<li><a href="#describing-rotation-in-3d">Describing rotation in 3D</a></li>
<li><a href="#rotations-are-non-commutative-in-3d">Rotations are non commutative in 3D</a></li>
<li><a href="#rotation-angle-sequences-in-3d">Rotation angle sequences in 3D</a></li>
<li><a href="#singularity-in-3d-rotation-angles-sequences">Singularity in 3D rotation angles sequences</a></li>
<li><a href="#vector-representation-of-rotation-in-3d">2-vector representation of rotation in 3D</a></li>
<li><a href="#angle-axis-representation-of-rotation-in-3d">Angle-axis representation of rotation in 3D</a></li>
<li><a href="#describing-rotation-and-translation-in-3d">Describing rotation and translation in 3D</a></li>
</ul></li>
<li><a href="#forward-kinematics">Forward Kinematics</a><ul>
<li><a href="#types-of-robots">Types of Robots</a></li>
<li><a href="#analysing-a-very-simple-1-joint-robot-arm">Analysing a very simple 1-joint robot arm</a></li>
<li><a href="#analysing-a-2-joint-planar-robot-arm">Analysing a 2-joint planar robot arm</a></li>
<li><a href="#analysing-a-3-joint-planar-robot-arm">Analysing a 3-joint planar robot arm</a></li>
<li><a href="#analysing-a-robot-arm-that-moves-in-3d">Analysing a robot arm that moves in 3D</a></li>
<li><a href="#task-and-configuration-space">Task and Configuration space</a></li>
<li><a href="#denavit-hartenberg-notation">Denavit-Hartenberg notation</a></li>
<li><a href="#base-and-tool-transforms">Base and tool transforms</a></li>
</ul></li>
<li><a href="#inverse-kinematics">Inverse Kinematics</a><ul>
<li><a href="#inverse-kinematics-for-a-2-joint-robot-arm-using-geometry">Inverse Kinematics for a 2-Joint Robot Arm Using Geometry</a></li>
<li><a href="#inverse-kinematics-for-a-2-joint-robot-arm-using-algebra">Inverse Kinematics for a 2-Joint Robot Arm Using Algebra</a></li>
<li><a href="#inverse-kinematics-for-a-general-purpose-robot-arm-that-moves-in-3d">Inverse Kinematics for a General Purpose Robot Arm That Moves in 3D</a></li>
<li><a href="#robot-arm-configuration-change">Robot Arm Configuration Change</a></li>
<li><a href="#different-approach-to-solving-inverse-kinematics">Different approach to solving inverse kinematics</a></li>
<li><a href="#numerical-inverse-kinematics">Numerical Inverse Kinematics</a></li>
<li><a href="#reachability-and-singularity">Reachability and Singularity</a></li>
<li><a href="#redundant-robots">Redundant Robots</a></li>
<li><a href="#joint-interpolated-motion">Joint Interpolated Motion</a></li>
<li><a href="#cartesian-interpolated-motion">Cartesian Interpolated Motion</a></li>
</ul></li>
<li><a href="#d-velocity-kinematics">2D Velocity Kinematics</a><ul>
<li><a href="#introduction-to-velocity-kinematics-in-2d">Introduction to Velocity Kinematics in 2D</a></li>
<li><a href="#velocity-of-2-joint-planar-robot-arm">Velocity of 2-Joint Planar Robot Arm</a></li>
<li><a href="#inverting-the-jacobian-matrix">Inverting the Jacobian Matrix</a></li>
<li><a href="#velocity-ellipse-in-2d">Velocity Ellipse in 2D</a></li>
<li><a href="#resolved-rate-motion-control-in-2d">Resolved Rate Motion Control in 2D</a></li>
<li><a href="#velocity-of-3-joint-planar-robot-arm">Velocity of 3-Joint Planar Robot Arm</a></li>
<li><a href="#mapping-2d-spatial-velocity-between-coordinate-frames">Mapping 2D Spatial Velocity Between Coordinate Frames</a></li>
</ul></li>
<li><a href="#d-velocity-kinematics-1">3D Velocity Kinematics</a><ul>
<li><a href="#motion-in-3d">Motion in 3D</a></li>
<li><a href="#velocity-of-6-joint-robot-arm---translation">Velocity of 6-Joint Robot Arm - Translation</a></li>
<li><a href="#skew-symmetric-matrices">Skew Symmetric Matrices</a></li>
<li><a href="#velocity-of-6-joint-robot-arm---rotation">Velocity of 6-Joint Robot Arm - Rotation</a></li>
</ul></li>
</ul>
</nav>
<hr />
<h1 id="d-geometry">2D Geometry</h1>
<hr />
<h2 id="d-geometry-refresher">2D Geometry Refresher</h2>
<h3 id="euclidean-geometry">Euclidean Geometry</h3>
<ul>
<li>Most common type of geometry.</li>
<li>From 300 BCE, as in the series of books called the “The Elements”.</li>
<li>It is the geometry of a plane and 3D space: lines, triangles, circles etc.</li>
<li>Based on a few axioms</li>
<li>Does not apply to non-planar surfaces such as a sphere, but can be a good approximation over small areas</li>
</ul>
<h3 id="cartesian-geometry">Cartesian Geometry</h3>
<ul>
<li>Added algebra to Euclidean geometry
<ul>
<li>Shapes could be expressed by equations</li>
</ul></li>
<li>Developed the coordinate system
<ul>
<li>Two axis: 2D coordinate frame</li>
</ul></li>
<li>Points: a location in the n-dimensional space
<ul>
<li>Use uppercase letters as its name</li>
</ul></li>
<li>Vectors: an ‘arrow’ from the origin of the coordinate frame to a point
<ul>
<li>Has components in each of the n-dimensions</li>
<li>Use lowercase letters as its name</li>
<li>Can be represented as a matrix
<ul>
<li>e.g. <span class="math inline">\(p = [\begin{matrix} a &amp; b \end{matrix}]^T\)</span></li>
</ul></li>
<li>Or can be represented using unit vectors
<ul>
<li><span class="math inline">\(p = a \hat{x} + b\hat{y}\)</span></li>
</ul></li>
<li>Can add and subtract vectors</li>
<li>Can multiply a vector by a scalar</li>
</ul></li>
</ul>
<h4 id="right-handed-coordinate-frame">Right-handed Coordinate Frame</h4>
<p>The y-axis is 90 degrees in an anti-clockwise direction from the x-axis.</p>
<hr />
<h2 id="position-and-pose-in-2d">Position and pose in 2D</h2>
<p>It may not be enough to describe an objects position by just x and y coordinates, it is desirable to also have orientation. Can do this by attaching a coordinate frame to the object. Now the objects orientation is described by the orientation of the attached coordinate frame with respect to the reference (world) coordinate frame.</p>
<p>Can describe the motion of an object in two steps:</p>
<ul>
<li><strong>Positional/Translational components</strong> Move from the reference coordinate frame to the object coordinate frame. First x, then y.</li>
<li><strong>Rotational component</strong> Then rotate to match the objects coordinate frame.</li>
</ul>
<p>It is convention that the x-axis is in the direction of normal motion for the machine.</p>
<h3 id="pose">Pose</h3>
<p>May be represented with this symbol, pronounced ksi,</p>
<p><span class="math display">\[\xi\]</span></p>
<p>where <span class="math inline">\(\xi\)</span> is</p>
<p><span class="math display">\[(x,y,\theta)\]</span></p>
<p><span class="math inline">\(^{A}p_B\)</span> where p is the vector to point B with respect to (from) A.</p>
<p><span class="math inline">\(^{A}\xi_B\)</span> where <span class="math inline">\(\xi\)</span> is the pose of B with respect to A.</p>
<p>Use pose to describe a coordinate frame with respect to another coordinate frame. Use a vector to describe a point with respect to a coordinate frame.</p>
<hr />
<h2 id="relative-positions-in-2d">Relative positions in 2D</h2>
<p>We can’t add poses and vectors.</p>
<p>If you have a pose <span class="math inline">\(^{W}\xi_C\)</span> and a vector <span class="math inline">\(^{C}p_d\)</span>, then to find <span class="math inline">\(^{W}p_d\)</span> you must transform the vector from one frame to another like</p>
<p><span class="math display">\[^Wp_d = ^W\xi_C \cdot ^Cp_d\]</span></p>
<hr />
<h2 id="relative-pose-in-2d">Relative pose in 2D</h2>
<p>Relative poses can be <strong>compounded</strong> or <strong>composed</strong> i.e. they can be ‘added’.</p>
<p>We use the symbol <span class="math inline">\(\oplus\)</span> for this, e.g.</p>
<p><span class="math display">\[^A\xi_C = ^A\xi_B \oplus ^B\xi_C\]</span></p>
<p>You can use a <strong>pose graph</strong> to better display and easily compute the relationships between the all of the poses. A pose graph is a directed graph, with solid edges between coordinate frames (nodes) indicating that the pose is known, and a dotted line indicating that the pose is unknown but perhaps it may be computed.</p>
<p>You can define an unknown pose with a composition of the known poses.</p>
<p>If when finding a pose it is necessary to travel backwards (in the reverse direction) in the graph, that may be represented using the symbol <span class="math inline">\(\ominus\)</span>.</p>
<h3 id="a-few-rules">A few rules</h3>
<p><span class="math display">\[^X\xi_Y \oplus ^Y\xi_Z = ^X\xi_Z\]</span></p>
<p><span class="math display">\[^Xp = ^X\xi_Y \cdot ^Yp\]</span></p>
<p><span class="math display">\[\xi_1 \oplus \xi_2 \neq \xi_2 \oplus \xi_1\]</span></p>
<p><span class="math display">\[\ominus ^X\xi_Y = ^Y\xi_X\]</span></p>
<span class="math display">\[\begin{aligned}
\xi \ominus \xi &amp;= 0   &amp;   \ominus \xi \oplus \xi &amp;= 0 \\
\xi \ominus 0 &amp;= \xi   &amp;   \xi \oplus 0 &amp;= \xi
\end{aligned}\]</span>
<hr />
<h2 id="describing-rotation-in-2d">Describing rotation in 2D</h2>
<p><img src="images/2d-geometry-07-understanding.png" /></p>
<p>Here <span class="math inline">\(^Ap\)</span> and <span class="math inline">\(^Bp\)</span> share an origin and so are the same. Equating these two gives</p>
<p><img src="images/2d-geometry-07-equate.png" /></p>
<p>which can be written in matrix form like</p>
<p><img src="images/2d-geometry-07-matrix.png" /></p>
<p>which can be more concisely written as</p>
<p><span class="math display">\[^A\boldsymbol{p} = \mathbf{R} ^B\boldsymbol{p} \qquad\text{ where
} \mathbf{R} = \begin{pmatrix} \cos{\theta} &amp; -\sin{\theta} \\ \sin{\theta}
&amp; \cos{\theta} \end{pmatrix}\]</span></p>
<p>but write it using the notation</p>
<p><span class="math display">\[^A\boldsymbol{p} =\ ^A\mathbf{R}_B \  ^B\boldsymbol{p} \qquad\text{
where } ^A\mathbf{R}_B = \begin{pmatrix} \cos{\theta} &amp; -\sin{\theta} \\
\sin{\theta} &amp; \cos{\theta} \end{pmatrix}\]</span></p>
<p>So <strong>R</strong> is a rotation matrix that</p>
<ul>
<li>rotates vectors from frame {B} to frame {A}</li>
<li>is a function of rotation angle from frame {A} to frame {B}</li>
</ul>
<h4 id="properties-of-the-rotation-matrix">Properties of the rotation matrix</h4>
<ul>
<li>Is an orthogonal (orthonormal) matrix
<ul>
<li>Each column is a unit vector</li>
<li>Each column is orthogonal to all other columns
<ul>
<li>the dot product of the two columns is zero</li>
</ul></li>
</ul></li>
<li>The inverse is the same as the transpose <span class="math inline">\(\boldsymbol{R}^{-1} = \boldsymbol{R}^T\)</span></li>
<li>The determinant is 1
<ul>
<li>Multiply any vector by the rotation matrix and the length of the vector is unchanged
<ul>
<li>so when rotating a vector from one coordinate frame to another, its length is not changed</li>
</ul></li>
</ul></li>
</ul>
<h4 id="inverse-rotation">Inverse rotation</h4>
<p>To rotate a vector from frame {A} to frame {B} we use the inverse rotation matrix, which for a rotation matrix is simply the transpose.</p>
<p>Also note the equivalence</p>
<p><span class="math display">\[^B\boldsymbol{R}_A =\ ^A\boldsymbol{R}^{-1}_B\]</span></p>
<hr />
<h2 id="describing-rotation-and-translation-in-2d">Describing rotation and translation in 2D</h2>
<p><img src="images/2d-geometry-08-homo.png" /></p>
<p>t is for translation.</p>
<p>I think a 3x3 matrix is preferred in the last step because then you can take the inverse (the zeros and ones in that last row are constant).</p>
<p><img src="images/2d-geometry-08-homo2.png" /></p>
<p><img src="images/2d-geometry-08-p.png" /></p>
<p>Remember the order when transforming:</p>
<p><img src="images/2d-geometry-08-order.PNG" /></p>
<h3 id="pose-1">Pose</h3>
<p>Pose is a matrix <span class="math inline">\(^A\xi_B \sim\ ^A\boldsymbol{T}_B\)</span></p>
<p>Compounding (composition) (<span class="math inline">\(\oplus\)</span>) is a matrix-matrix product.</p>
<p>Negation (<span class="math inline">\(\ominus\)</span>) is a matrix inverse.</p>
<p>Vector transformation (<span class="math inline">\(\cdot\)</span>) is a matrix-vector product.</p>
<p><span class="math display">\[\xi\cdot p \rightarrow \boldsymbol{T} \widetilde{p}\]</span></p>
<hr />
<h1 id="d-geometry-1">3D Geometry</h1>
<hr />
<h2 id="relative-pose-in-3d">Relative pose in 3D</h2>
<p>The pose notation using <span class="math inline">\(\xi\)</span> is exactly the same as in 2D, and the same rules apply.</p>
<p>The difference is in the implementation.</p>
<hr />
<h2 id="describing-rotation-in-3d">Describing rotation in 3D</h2>
<h4 id="rotation-in-3d">Rotation in 3D</h4>
<p>Frames {A} and {B} share the same origin.</p>
<p><img src="images/3d-geometry-07-transform.PNG" /></p>
<h4 id="properties-of-the-rotation-matrix-1">Properties of the rotation matrix</h4>
<ul>
<li>Is an orthogonal (orthonormal) matrix
<ul>
<li>Each column is a unit vector</li>
<li>Each column is orthogonal to all other columns
<ul>
<li>the dot product of the two columns is zero</li>
</ul></li>
</ul></li>
<li>The inverse is the same as the transpose <span class="math inline">\(\boldsymbol{R}^{-1} = \boldsymbol{R}^T\)</span></li>
<li>The determinant is 1
<ul>
<li>Multiply any vector by the rotation matrix and the length of the vector is unchanged
<ul>
<li>so when rotating a vector from one coordinate frame to another, its length is not changed</li>
</ul></li>
</ul></li>
</ul>
<h4 id="elementary-rotation-matrices">Elementary rotation matrices</h4>
<p>For rotation about either the x, y or z axis.</p>
<p>Multiplying these in various combinations will achieve much more complicated rotations.</p>
<p><img src="images/3d-geometry-07-elementary.PNG" /></p>
<hr />
<h2 id="rotations-are-non-commutative-in-3d">Rotations are non commutative in 3D</h2>
<p>The order in each rotations are applied in 3D is <strong>critically</strong> important; they are non commutative.</p>
<hr />
<h2 id="rotation-angle-sequences-in-3d">Rotation angle sequences in 3D</h2>
<h4 id="eulers-rotation-theorem">Euler’s rotation theorem</h4>
<p>(Paraphrased)</p>
<p>Any rotation can be expressed by a sequence of rotations (not more than three), where no two successive rotations are about the same axis.</p>
<h4 id="euler-angles">Euler angles</h4>
<p>These are the set of rotations where there are two rotations about the same axis (but not sequentially).</p>
<p><strong>XYX, XZX, YXY, YZY, ZXZ, ZYZ</strong></p>
<p><strong>ZYZ</strong> is commonly referred to as ‘Euler angles’, but mind it is only one of the six possible.</p>
<p>Euler angles are not unique a representation of orientation in space.</p>
<p>Rotate on new axis.</p>
<p>For the Euler angle approach, the order of the matrix multiplication and transformations are the same as the order they occur.</p>
<h4 id="cardan-angles">Cardan angles</h4>
<p>These are the remaining sets of rotation sequences which satisfy Euler’s rotation theorem. All rotations are about different axes.</p>
<p>They are</p>
<p><strong>XYZ, XZY, YXZ, YZX, ZXY, ZYX</strong></p>
<p><strong>XYZ</strong> and <strong>ZYX</strong> are both commonly referred to as <em>roll pitch yaw</em> angles. Which one is referred to depends on the context. <strong>XYZ</strong> seems to be the default for Robotics M course.</p>
<p>Rotate on original axis.</p>
<p>For fixed angle approach: the order of transformations (including translation) should be all reversed. Say a frame {B} is located as follows: initially coincident with a frame {A}, we perform a rotation about ZA axis, followed a rotation about YA axis, followed by a translation along [XA, YA, ZA].</p>
<p>Then the transformation matrix (4X4) is: Trans[XA, YA, ZA].Rot(YA).Rot(ZA)</p>
<hr />
<h2 id="singularity-in-3d-rotation-angles-sequences">Singularity in 3D rotation angles sequences</h2>
<p>Also known as <strong>Gimbal lock</strong>.</p>
<p>A Gimbal is a mechanism used to stabilise some device to space.</p>
<figure>
<img src="images/3d-geometry-10-gimbal.PNG" alt="Examples of Gimbals" /><figcaption>Examples of Gimbals</figcaption>
</figure>
<p>Gimbal lock is when two of the axis become aligned.</p>
<p>For roll-pitch-yaw angles, Gimbal lock occurs when pitch is at <span class="math inline">\(\pi/2\)</span>. Results in rotation axes of the first and third rotations (roll and yaw) parallel.</p>
<p>For example, the set of roll-pitch-yaw angles (30, 90, -20)° is equivalent to the set (0, 90, 10)°. A pitch of 90° results in Gimbal lock, whereby the roll and yaw axes become aligned, and thus rotations about these axes can be summed and by convention assigned to the yaw angle.</p>
<p>To minimise Gimbal lock, choose coordinate conventions so that the pitch angle is around 0 for normal operating conditions.</p>
<hr />
<h2 id="vector-representation-of-rotation-in-3d">2-vector representation of rotation in 3D</h2>
<p>Describes the orientation of the end effector.</p>
<h4 id="axis-representation">2-axis representation</h4>
<p><img src="images/3d-geometry-11-end-effector.PNG" /></p>
<p><img src="images/3d-geometry-11-matrix.PNG" /></p>
<p>All three columns of the rotation matrix are orthogonal, hence one of the vectors can be computed from the other two.</p>
<p><img src="images/3d-geometry-11-calc.PNG" /></p>
<hr />
<h2 id="angle-axis-representation-of-rotation-in-3d">Angle-axis representation of rotation in 3D</h2>
<p>The orientation of a body in 3D can also be described by a single rotation about a particular axis in space.</p>
<p>Need to know the axis of rotation vector <span class="math inline">\(\boldsymbol{v}\)</span>, and the angle of rotation about the vector <span class="math inline">\(\boldsymbol{\theta}\)</span>.</p>
<h4 id="finding-the-axis">Finding the axis</h4>
<p>We observe that the axis around which the rotation occurs must be unchanged by the rotation, therefore the rotation axis must be an eigenvector of <span class="math inline">\(\boldsymbol{R}\)</span>.</p>
<p>A rotation matrix has three eigenvectors:</p>
<ul>
<li>one real eigenvector corresponding to an eigenvalue of 1</li>
<li>two complex eigenvectors with eigenvalues <span class="math inline">\(\lambda = \cos{\theta} \pm i \sin{\theta}\)</span> where <span class="math inline">\(\theta\)</span> is the rotation angle</li>
</ul>
<h4 id="finding-the-rotation-matrix">Finding the rotation matrix</h4>
<p>If you know <span class="math inline">\(\theta\)</span> and the eigenvector, then the rotation matrix can be found using the Rodrigues equation.</p>
<p><img src="images/3d-geometry-12-skew.PNG" /></p>
<hr />
<h2 id="describing-rotation-and-translation-in-3d">Describing rotation and translation in 3D</h2>
<p>Pose has</p>
<ul>
<li>a <strong>translational</strong> component, and</li>
<li>a <strong>rotational</strong> component</li>
</ul>
<p>It can be represented by</p>
<ul>
<li>vector + Euler angles</li>
<li>vector + roll-pitch-yaw angles (fixed angles)</li>
<li>vector + Quaternion</li>
<li>Homogeneous transformation</li>
</ul>
<figure>
<img src="images/3d-geometry-14-homo_trans.PNG" alt="homogeneous transform matrix" /><figcaption>homogeneous transform matrix</figcaption>
</figure>
<p>Using the rotation matrix avoids singularity’s, unlike the Euler and fixed angle approaches.</p>
<hr />
<h1 id="forward-kinematics">Forward Kinematics</h1>
<hr />
<h2 id="types-of-robots">Types of Robots</h2>
<p>A serial-link manipulator consists of a series of joints, each connected by a rigid link to the following joint.</p>
<p>A parallel-link manipulator consists of one or more joints on the base, each connected by a rigid link to the end-effector.</p>
<p>Other types: SCARA robot (Selective Compliance Articulating Robot), Gantry robot - overhead (x,y,z).</p>
<p>Robotic joints can either rotate or slide</p>
<ul>
<li>rotate - revolute joint</li>
<li>slide - prismatic joint</li>
</ul>
<hr />
<h2 id="analysing-a-very-simple-1-joint-robot-arm">Analysing a very simple 1-joint robot arm</h2>
<p>Get to the end effector frame by rotating and translating the reference coordinate frame.</p>
<p><img src="images/forward-kinematics-03-arm.png" /></p>
<p>Both position and angle is a function of the angle <span class="math inline">\(q_1\)</span> and so the position and angle cannot be set independently.</p>
<p>i.e. can move to any point lying on a circle</p>
<hr />
<h2 id="analysing-a-2-joint-planar-robot-arm">Analysing a 2-joint planar robot arm</h2>
<p>Same as for 1-joint, the orientation of the end effector is not independent from its position in the xy plane.</p>
<p>Always two joint angle configurations that result in the same end effector position.</p>
<p><img src="images/forward-kinematics-04-arm.png" /></p>
<hr />
<h2 id="analysing-a-3-joint-planar-robot-arm">Analysing a 3-joint planar robot arm</h2>
<p>Unlike the 1 and 2 joint planar robotic arm, the orientation and position of the end effector are independent.</p>
<p>There are an infinite number of joint configurations that result in an end-effector position.</p>
<p><img src="images/forward-kinematics-05-arm.png" /></p>
<hr />
<h2 id="analysing-a-robot-arm-that-moves-in-3d">Analysing a robot arm that moves in 3D</h2>
<p>To find the end-effectors pose, the process is much the same as for a planar robot arm, multiply a bunch of rotation and translation matrices.</p>
<p>First identify the joints of the robot. Then a good way to figure out the order of the multiplications is to imagine the grippers/end-effector of the robot pointing up, coming out of the base of robot. Then imagine the rotations and translations as the end-effector approaches each joint.</p>
<hr />
<h2 id="task-and-configuration-space">Task and Configuration space</h2>
<h3 id="configuration-space">Configuration Space</h3>
<p>q (<em>joint configuration</em>) is a vector of length N (<em>number of joints</em>) where the elements of q (<em>joint coordinate</em>) are either an angle or a length.</p>
<p>q belongs to the space C (<em>space of all possible configurations</em>), which is a subset of the N dimensional space.</p>
<p><img src="images/forward-kinematics-08-joints.png" /></p>
<h3 id="task-space">Task Space</h3>
<p>There is also the space of all possible end-effector poses, T.</p>
<h3 id="task-and-configuration-space-dimensions">Task and Configuration Space Dimensions</h3>
<p>The dimension of the configuration space is the <em>robots</em> degrees of freedom, i.e. the number of joints.</p>
<p>The dimension of the task space is the degrees of freedom in the task space.</p>
<p>In the three dimensional world (that we and our robots live), it is not possible to have a task space bigger than six.</p>
<p><strong>To reach all of the task space</strong> dim C <span class="math inline">\(&gt;=\)</span> dim T</p>
<h3 id="redundant-robot">Redundant Robot</h3>
<p>When dim C &gt; dim T (especially when dim C &gt;&gt; dim T), the shape of the arm can be controlled as well as the position/orientation of the end-effector.</p>
<hr />
<h2 id="denavit-hartenberg-notation">Denavit-Hartenberg notation</h2>
<p>A general theory to describe an articulated sequence of joints.</p>
<p>Each joint in the robot is described by four parameters.</p>
<p>Denavit-Hartenberg notation describes the relationship between 3D coordinate frames attached to two successive links with four parameters.</p>
<p>For a robot with N joints the links are numbered from 0 to N, where link 0 is the fixed base of the robot.</p>
<ul>
<li><p>A coordinate frame is attached to the far (distal) end of every link (closest to the end-effector)</p></li>
<li><p>The pose of a link frame is described with respect to the previous link frame</p></li>
<li><p>Four parameters: <span class="math inline">\(\theta, d, a, \alpha\)</span></p></li>
</ul>
<p><img src="images/forward-kinematics-09-diagram.png" /> <img src="images/forward-kinematics-09-equation.png" /></p>
<h3 id="how-only-4-parameters-when-a-pose-has-6-parameters">How only 4 parameters when a pose has 6 parameters?</h3>
<p>There are constraints when using Denavit-Hartenberg notation:</p>
<ul>
<li><p>Axis <span class="math inline">\(x_j\)</span> intersects axis <span class="math inline">\(z_(j-1)\)</span></p></li>
<li><p>Axis <span class="math inline">\(x_j\)</span> is perpendicular to axis <span class="math inline">\(z_(j-1)\)</span></p></li>
</ul>
<p>6 parameters - 2 constraints = 4 parameters</p>
<p>Note that because of these constraints, a link coordinate frame may not necessarily lie on the physical robot.</p>
<h3 id="the-joint-axis">The Joint Axis</h3>
<p>The axis of each joint is defined by the z-axis of a coordinate frame</p>
<ul>
<li><p>The joint <strong>rotates</strong> about the z-axis (revoltue joint), or</p></li>
<li><p>The joint translates along the z-axis (prismatic joint)</p></li>
</ul>
<h3 id="parameter-table">Parameter Table</h3>
<p>A table is used to represent each of the DH parameters for each joint.</p>
<p>A good way to remember how to find each of the parameters is to use the following table.</p>
<p><img src="images/forward-kinematics-09-tutorial.png" /></p>
<hr />
<h2 id="base-and-tool-transforms">Base and tool transforms</h2>
<p>In reality, we want the end point of the robot to be the end of whatever tool is attached to the robot. Need to apply a tool transform to the end pose of the robot.</p>
<p>Also can apply a <em>base</em> transform to reposition or reorient the robot in space, i.e. flip the robot upside down etc.</p>
<hr />
<h1 id="inverse-kinematics">Inverse Kinematics</h1>
<hr />
<h2 id="inverse-kinematics-for-a-2-joint-robot-arm-using-geometry">Inverse Kinematics for a 2-Joint Robot Arm Using Geometry</h2>
<p>The derived inverse kinematic function has two solutions</p>
<p><img src="images/inverse-kinematics-02-solutions.PNG" /></p>
<hr />
<h2 id="inverse-kinematics-for-a-2-joint-robot-arm-using-algebra">Inverse Kinematics for a 2-Joint Robot Arm Using Algebra</h2>
<p>Determine the transformation matrix for the end-effector and pick out the translation parts. Now you have equations for x=… and y=… so then solve for the angles.</p>
<hr />
<h2 id="inverse-kinematics-for-a-general-purpose-robot-arm-that-moves-in-3d">Inverse Kinematics for a General Purpose Robot Arm That Moves in 3D</h2>
<p>A 6-link industrial robot such as the Puma 560 has eight different arm configurations.</p>
<p>The arm can be in either a left-handed or right-handed configuration, 2 possible configurations. In addition the elbow can be either above or below the shoulder, another 2 possible configurations. Finally the gripper can be at a particular angle about the gripper axis, or the same angle plus 180 degrees — for a common two-fingered or parallel jaw gripper it makes no difference. This is another 2 possible configurations. In total there are 2x2x2 possible configurations, a total of 8.</p>
<hr />
<h2 id="robot-arm-configuration-change">Robot Arm Configuration Change</h2>
<p>A configuration change is a motion that starts and ends with the same end-effector configuration.</p>
<p>Used for switching from left-handed configuration to right-handed, and vice versa.</p>
<hr />
<h2 id="different-approach-to-solving-inverse-kinematics">Different approach to solving inverse kinematics</h2>
<h3 id="spherical-wrist">Spherical wrist</h3>
<p>Many 6-DOF robots have a spherical wrist. This is where all 3 wrist joint axes intersect at a single point.</p>
<h3 id="numerical-solution">Numerical Solution</h3>
<p>The analytic solution may be too hard to compute or not exist.</p>
<hr />
<h2 id="numerical-inverse-kinematics">Numerical Inverse Kinematics</h2>
<p>Initial conditions will determine the configuration of the end pose, trial and error may be needed, i.e. can’t guarantee a particular configuration.</p>
<p>Can be computationally expensive (iterative algorithm).</p>
<p>Numerical inverse kinematics works well for redundant robots.</p>
<hr />
<h2 id="reachability-and-singularity">Reachability and Singularity</h2>
<h3 id="reachability">Reachability</h3>
<p>Robot may not be able to reach the requested pose</p>
<ul>
<li>Numerical algorithm may fail to converge</li>
<li>Analytic approach may try computing square root of a negative number or the inverse cosine of a number whose magnitude is greater than 1</li>
</ul>
<h3 id="singularity">Singularity</h3>
<p>Related to the Gimbal lock problem.</p>
<p>If particular axes are aligned, can loose a degree of freedom, affecting the robots ability to reach some positions.</p>
<hr />
<h2 id="redundant-robots">Redundant Robots</h2>
<p>Very high DOF robot.</p>
<ul>
<li>Configuration space is much bigger than the task space</li>
<li>Can independently control the shape of the robot and the end-effector pose</li>
</ul>
<p>Use a numerical approach to solve for joint angles.</p>
<hr />
<h2 id="joint-interpolated-motion">Joint Interpolated Motion</h2>
<p>How to smoothly move from one pose to another.</p>
<p>Simple approach.</p>
<ul>
<li>Determine the joint angles at start and end pose
<ul>
<li>interpolate between them</li>
</ul></li>
</ul>
<p>No constraints on the path except for the start and end points</p>
<ul>
<li>May result in translations or orientations changing throughout the path even when its start and end positions are the same. (not a straight line or constant orientation)</li>
</ul>
<hr />
<h2 id="cartesian-interpolated-motion">Cartesian Interpolated Motion</h2>
<p>Determine the pose at each intermediate point</p>
<ul>
<li>then use inverse kinematics to find the joint angles.</li>
</ul>
<p>Results in straight line motion in 3D space.</p>
<p>Still, there is little difference between Cartesian interpolated motion and joint books interpolated motion.</p>
<ul>
<li>although Cartesian interpolated motion is more computationally expensive</li>
</ul>
<hr />
<h1 id="d-velocity-kinematics">2D Velocity Kinematics</h1>
<hr />
<h2 id="introduction-to-velocity-kinematics-in-2d">Introduction to Velocity Kinematics in 2D</h2>
<p>If the joints move at this particular joint velocity, what is the velocity of the end-effector?</p>
<p><strong>Rate of change of a pose.</strong></p>
<hr />
<h2 id="velocity-of-2-joint-planar-robot-arm">Velocity of 2-Joint Planar Robot Arm</h2>
<ol type="1">
<li><p>Find the expression for x and y (as a function of the joint angles) just like in when finding the inverse kinematics.</p></li>
<li><p>Make the joint angles functions of time</p></li>
<li><p>Take the derivative of x and y</p></li>
<li><p>Factor out the <span class="math inline">\(\dot{q_1}\)</span> and <span class="math inline">\(\dot{q_2}\)</span> so the equation is in matrix form</p></li>
<li><p>This can be written as <span class="math inline">\(v = \mathbf{J}(q)\dot{q}\)</span></p>
<ul>
<li><p><span class="math inline">\(v\)</span> is the tip velocity</p></li>
<li><p><span class="math inline">\(\mathbf{J}(q)\)</span> is the Jacobian matrix</p></li>
</ul></li>
</ol>
<h4 id="the-jacobian">The Jacobian</h4>
<p>The Jacobian is the matrix equivalent of the derivative.</p>
<p><img src="images/2d-velocity-kinematics-03-Jacobian.PNG" /></p>
<p>Here the Jacobian is a function of the joint angles and the kinematic parameters of the robot.</p>
<h4 id="spatial-velocity">Spatial Velocity</h4>
<p>Greek letter nu, <span class="math inline">\(nu\)</span></p>
<ul>
<li>Used to denote the robot tool velocity (including rotation)</li>
<li>The end-effector spatial velocity is the product of the manipulator Jacobian matrix and the joint velocity vector.</li>
</ul>
<hr />
<h2 id="inverting-the-jacobian-matrix">Inverting the Jacobian Matrix</h2>
<p>Given the end-effector velocity, what are the joint velocities?</p>
<p><span class="math inline">\(\dot{q} = \mathbf{J}(q)^{-1}v\)</span></p>
<p>The Jacobian can only be inverted if it is</p>
<ul>
<li><p><strong>square</strong>: the robot’s task and configuration spaces are equal, and</p></li>
<li><p><strong>non-singular</strong>: the robot’s joint coordinates avoid certain “singular” configurations.</p></li>
</ul>
<h4 id="singular-jacobian-matrix">Singular Jacobian matrix</h4>
<p>A singular Jacobian matrix indicates that the end-effector motion is unable to move in or rotate about a particular Cartesian direction. (loss of a DOF)</p>
<h5 id="close-to-singular">Close to singular</h5>
<p>A pose may be <em>nearly</em> singular, making movement in some directions difficult.</p>
<p>Can be determined by the Jacobian determinant or the Jacobian condition number.</p>
<p>A small determinant corresponds to a large condition number, that is, the matrix is nearly singular.</p>
<hr />
<h2 id="velocity-ellipse-in-2d">Velocity Ellipse in 2D</h2>
<p>The velocity ellipse describes the ease in which the robot arm may move in either direction.</p>
<ul>
<li>The short axis indicates the direction in which the end-effector can move least quickly</li>
<li>Conversely, the long axis is the direction in which it can move most quickly</li>
</ul>
<p>A narrow ellipse means the robot is close to a singularity.</p>
<p>It can be described by the equation <span class="math display">\[\nu^T (\mathbf{J}(\mathbf{q})\mathbf{J}^T(\mathbf{q}))^{-1} \nu = 1\]</span> Where <span class="math display">\[\nu=(\dot{x},\dot{y})\]</span> and <span class="math display">\[\mathbf{\dot{q}}=(\dot{q_1},\dot{q_2})\]</span> <span class="math display">\[\mathbf{\dot{q}}=\mathbf{J}(\mathbf{q})^{-1}\nu\]</span></p>
<p><img src="images/2d-velocity-kinematics-05-intuition.PNG" /></p>
<p>Moving faster in the y direction than x.</p>
<hr />
<h2 id="resolved-rate-motion-control-in-2d">Resolved Rate Motion Control in 2D</h2>
<p>Resolved-rate motion control is a technique to move the end-effector at a specified velocity without having to compute inverse kinematics.</p>
<ol type="1">
<li><p>Choose the Cartesian velocity <span class="math inline">\(\nu\)</span></p></li>
<li><p>Find the joint velocities using the inverse Jacobian</p></li>
<li><p>Move the joints at that speed</p>
<ul>
<li>i.e. Find the next joint configuration <span class="math inline">\(\mathbf{q}_{k+1} = \mathbf{q}_k + \Delta_t \mathbf{\dot{q}}\)</span> and send that to the robots hardware</li>
</ul></li>
<li><p>At the next time step, update the Jacobian as it is a function of the joint angles, which have now changed</p></li>
<li><p>Goto step 2</p></li>
</ol>
<p>This technique may or may not be less computationally expensive than computing the inverse kinematics at every step.</p>
<hr />
<h2 id="velocity-of-3-joint-planar-robot-arm">Velocity of 3-Joint Planar Robot Arm</h2>
<p>Remember a 3-joint planar arm is able to control its orientation independently of its position.</p>
<p>Find the forward kinematics transform matrix, then</p>
<ul>
<li>take the derivative of the translation part and arrange in matrix form,</li>
<li>then do the same for the rotational part,</li>
<li>stack them together and you have the 3x3 Jacobian matrix multiplied by the joint velocity vector equals the spatial velocity.</li>
</ul>
<p><img src="images/2d-velocity-kinematics-07-spatial.PNG" /></p>
<p>Therefore</p>
<p><img src="images/2d-velocity-kinematics-07-tool.PNG" /></p>
<p>Also note</p>
<ul>
<li>the number of <strong>rows</strong> of the Jacobian matrix is equal to the dimension of the robot’s <strong>task</strong> space,</li>
<li>and the number of <strong>columns</strong> of the Jacobian matrix is equal to the dimension of the robot’s <strong>configuration</strong> space.</li>
</ul>
<hr />
<h2 id="mapping-2d-spatial-velocity-between-coordinate-frames">Mapping 2D Spatial Velocity Between Coordinate Frames</h2>
<p>The velocity of a point relative to coordinate frame A is related to its velocity relative to frame B by a Jacobian which is a function of the rotation from frame B to frame A.</p>
<p><img src="images/2d-velocity-kinematics-08-coord.PNG" /></p>
<hr />
<h1 id="d-velocity-kinematics-1">3D Velocity Kinematics</h1>
<hr />
<h2 id="motion-in-3d">Motion in 3D</h2>
<p>The spatial velocity <span class="math inline">\(\nu\)</span>, also called twist, is a vector of six parameters that describes the instantaneous velocity in 3D.</p>
<p><span class="math display">\[\mathbf{\nu}=(\nu_x,\nu_y,\nu_z,\omega_x,\omega_y,\omega_z)\]</span></p>
<p>Three of these elements describe the velocity of a point moving in 3D-space, and the other three describe the angular velocity of a body rotating in 3D-space.</p>
<hr />
<h2 id="velocity-of-6-joint-robot-arm---translation">Velocity of 6-Joint Robot Arm - Translation</h2>
<p>For a 6-link robot, the previous approach to computing the Jacobian becomes unwieldy so a numerical approximation to the forward kinematic function is computed instead.</p>
<p>Just like when you learnt calculus</p>
<p><img src="images/3d-velocity-kinematics-03-approx.PNG" /></p>
<p>The derivative is approximated by calculating a finite difference.</p>
<ol type="1">
<li>Find the transformation matrix for some pose</li>
<li>Then slightly displace <strong>one</strong> of the joints and then calculate the transformation matrix. A slight displacement may be 0.01 rad <span class="math inline">\(\approx\)</span> 0.5 deg, not too small or hardware might become inaccurate.</li>
<li>Then <span class="math inline">\(\frac{\partial T}{\partial q_1} \approx \frac{\mathbf{T(q)} - \mathbf{T(q&#39;)}}{displacement_of_joint_1}\)</span></li>
<li>From this it is easy to extract out the parts that correspond to the partial derivative of the rotation matrix with respect to joint angle 1, <span class="math inline">\(\frac{\partial\mathbf{R}}{\partial q_1}\)</span>, and similarly for the translation portion, <span class="math inline">\(\frac{\partial\mathbf{t}}{\partial q_1}\)</span>.</li>
</ol>
<h3 id="what-about-the-end-effector">What About the End-Effector?</h3>
<h4 id="translation">Translation</h4>
<p>What to do if you want to find the end-effectors <strong>translational velocity</strong>?</p>
<p>Well this can also be said to be <em>the rate of change of translation with respect to time</em>.</p>
<p>This can be found by multiplying the partial derivative of the robots position with respect to <span class="math inline">\(q_1\)</span> and the rate of change of <span class="math inline">\(q_1\)</span> with respect to time.</p>
<p><span class="math display">\[\frac{\partial\mathbf{t}}{\partial q_1} \frac{dq_1}{dt} = \frac{d\mathbf{t}}{dt}\]</span></p>
<p>The end-effectors translational velocity, <span class="math inline">\(\frac{d\mathbf{t}}{dt}\)</span>, can be expressed as <span class="math inline">\(\begin{pmatrix} \dot{x} \\ \dot{y} \\ \dot{z} \end{pmatrix}\)</span> or <span class="math inline">\(\begin{pmatrix} \v_x \\ \v_y \\ \v_z \end{pmatrix}\)</span>.</p>
<p>Should end with an expression like</p>
<p><span class="math display">\[\begin{pmatrix} \v_x \\ \v_y \\ \v_z \end{pmatrix} \approx \begin{pmatrix} ? \\ ? \\ ? \end{pmatrix} \dot{q_1}\]</span></p>
<h4 id="rotation">Rotation</h4>
<p>The same can be done for the rotational part with some differences.</p>
<p>Using <span class="math inline">\(\frac{\partial\mathbf{R}}{\partial q_1}\)</span> from step 4,</p>
<p><span class="math display">\[\frac{\partial\mathbf{R}}{\partial q_1} \frac{dq_1}{dt} = \frac{d\mathbf{R}}{dt}\]</span></p>
<p>Note that <span class="math inline">\(\mathbf{\dot{R}}=\mathbf{S}(\omega)\mathbf{R}\)</span>, where <span class="math inline">\(\mathbf{S}(\omega)\)</span> is the skew symmetric matrix.</p>
<hr />
<h2 id="skew-symmetric-matrices">Skew Symmetric Matrices</h2>
<ul>
<li>Also known as an anti symmetric matrix.</li>
</ul>
<p><span class="math display">\[\mathbf{S}^T=-\mathbf{S}\]</span> <span class="math display">\[\mathbf{S}^T+\mathbf{S}=0\]</span></p>
<ul>
<li><p>Always singular <span class="math display">\[det S = 0\]</span></p></li>
<li><p>Any matrix is the sum of symmetric and a skew symmetric matrix</p></li>
<li><p>In 3 dimensions <img src="images/3d-velocity-kinematics-04-matrix.PNG" /></p></li>
<li><p>An alternative way to express the vector cross product <span class="math inline">\(\mathbf{a} \times \mathbf{b}=\mathbf{S}(\mathbf{a})\mathbf{b}\)</span></p></li>
</ul>
<h3 id="other-properties">Other Properties</h3>
<ul>
<li>Zero diagonal</li>
<li>Exclusion: row x, column y, the element must be a z</li>
<li>Cyclic rotation (x,y,z,x,y,z,..)
<ul>
<li>sequential -&gt; positive: column x, row y; column z, row x</li>
<li>non sequential -&gt; negative: column x, row z; column z, row y</li>
</ul></li>
</ul>
<hr />
<h2 id="velocity-of-6-joint-robot-arm---rotation">Velocity of 6-Joint Robot Arm - Rotation</h2>
<p>Continuing on from <a href="#rotation">the translational section above</a>, we have to rearrange the expression</p>
<p><span class="math display">\[\frac{\partial\mathbf{R}}{\partial q_1} \frac{dq_1}{dt} = \frac{d\mathbf{R}}{dt}\]</span></p>
<p>to get <span class="math inline">\(\mathbf{S}(\omega)\)</span>.</p>
<p>Take the inverse of <span class="math inline">\(\mathbf{R}\)</span> (which is the same as the transpose for a rotation matrix) to get</p>
<p><span class="math display">\[\mathbf{S}(\omega) = \frac{\partial\mathbf{R}}{\partial q_1} \mathbf{R}^T \dot{q_1}\]</span></p>
<p>then compute numerically.</p>
<p>Then using our knowledge of skew symmetric matrix properties, can find <span class="math inline">\(\omega_x\)</span>, <span class="math inline">\(\omega_y\)</span> and <span class="math inline">\(\omega_z\)</span>, then rewrite it in matrix form as</p>
<p><span class="math display">\[\begin{pmatrix} \omega_x \\ \omega_y \\ \omega_z \end{pmatrix} \approx \begin{pmatrix} ? \\ ? \\ ? \end{pmatrix} \dot{q_1}\]</span></p>
<h3 id="combining-translation-and-rotation">Combining Translation and Rotation</h3>
<p>Simply stack the translation and rotation vectors on top of each other to get the relationship between the spatial velocity and the velocity of the robots first joint angle.</p>
<p><span class="math display">\[\begin{pmatrix} \v_x \\ \v_y \\ \v_z \\ \omega_x \\ \omega_y \\ \omega_z \end{pmatrix} \approx \begin{pmatrix} ? \\ ? \\ ? \\ ? \\ ? \\ ? \end{pmatrix} \dot{q_1}\]</span></p>
<h4 id="repeat-for-all-joints">Repeat for all joints</h4>
<p><span class="math display">\[\begin{pmatrix} \v_x \\ \v_y \\ \v_z \\ \omega_x \\ \omega_y \\ \omega_z \end{pmatrix} \approx \text{[6x6 matrix] } \begin {pmatrix} \dot{q_1}\\\dot{q_2}\\\dot{q_3}\\\dot{q_4}\\\dot{q_5}\\\dot{q_6} \end{pmatrix}\]</span></p>
<p>The 6x6 matrix is a Jacobian matrix, referred to as the manipulator Jacobian matrix.</p>
<p>Can alternatively express this as <span class="math inline">\(\nu = \mathbf{J}(\mathbf{q})\mathbf{\dot{q}}\)</span>.</p>
<p>Each column of the Jacobian matrix is the contribution by the robots joint <span class="math inline">\(i\)</span> to the end-effectors spatial velocity. Add them together to get the total end-effector spatial velocity.</p>
</body>
</html>
